# Architecture Decision Records (ADRs)

## ADR-001: Arquitectura Hexagonal

### Contexto

Necesitamos una arquitectura que permita independencia del dominio respecto a frameworks, bases de datos y servicios externos, facilitando testabilidad y mantenibilidad.

### Decisión

Implementar **Arquitectura Hexagonal (Ports & Adapters)** con las siguientes capas:

1. **Dominio** (Centro):
   - Entidades, Value Objects, Aggregates
   - Lógica de negocio pura
   - Sin dependencias externas
   - Eventos de dominio

2. **Aplicación**:
   - Casos de uso (Commands/Queries)
   - Handlers
   - Orquestación de dominio

3. **Infraestructura** (Periferia):
   - Adaptadores de persistencia (PostgreSQL)
   - Adaptadores de mensajería (RabbitMQ)
   - Adaptadores de transporte (HTTP/Fiber)
   - Configuración y servicios externos

### Puertos (Interfaces)

```go
// Puerto definido en dominio
type UserRepository interface {
 Save(ctx context.Context, user *entities.User) error
 FindByID(ctx context.Context, tenantID string, id uuid.UUID) (*entities.User, error)
 FindByEmail(ctx context.Context, tenantID string, email value_objects.Email) (*entities.User, error)
 ExistsByEmail(ctx context.Context, tenantID string, email value_objects.Email) (bool, error)
}


// Adaptador implementado en infraestructura
type GormUserRepository struct {
 db *gorm.DB
}


```

### Consecuencias

**Positivas:**

- Dominio totalmente testeable sin dependencias
- Facilidad para cambiar BD o framework
- Clara separación de responsabilidades
- Migraciones de tecnología sin impacto en dominio

**Negativas:**

- Mayor cantidad de código (interfaces, adaptadores)
- Curva de aprendizaje inicial
- Puede ser over-engineering para proyectos simples
