# Architecture Decision Records (ADRs)

## ADR-003: Multi-tenancy a Nivel de Aplicación

### Contexto

La aplicación debe soportar múltiples clientes (tenants) manteniendo sus datos aislados y ofreciendo configuraciones independientes.

### Decisión

Implementar **multi-tenancy a nivel de aplicación** usando:

1. **Discriminador por Tenant:**
   - Header HTTP: `X-Tenant-Id` (obligatorio)
   - Almacenado en `c.Locals("tenant_id")`
   - Incluido en todas las consultas a BD

2. **Aislamiento de Datos:**

    ```sql
    -- Todas las tablas incluyen tenant_id
    CREATE TABLE users (
        id UUID PRIMARY KEY,
        tenant_id VARCHAR(100) NOT NULL,
        email VARCHAR(255) NOT NULL,
        CONSTRAINT unique_email_per_tenant UNIQUE (tenant_id, email)
    );

    -- Índices compuestos para performance
    CREATE INDEX idx_users_tenant_id ON users(tenant_id);
    ```

3. **Scoping en Queries:**

    ```go
    func (r *Repository) FindByID(ctx context.Context, tenantID string, id UUID) {
        query := `SELECT * FROM users WHERE id = $1 AND tenant_id = $2`
        // tenant_id SIEMPRE incluido
    }
    ```

4. **Middleware de Validación:**

```go
func TenantMiddleware() fiber.Handler {
    return func(c *fiber.Ctx) error {
        tenantID := c.Get("X-Tenant-Id")
        if tenantID == "" {
            return c.Status(400).JSON(...)
        }
        c.Locals("tenant_id", tenantID)
        return c.Next()
    }
}
```

### Consecuencias

**Positivas:**

- Fácil onboarding de nuevos tenants
- Costos de infraestructura optimizados
- Single deployment
- Configuraciones flexibles por tenant

**Negativas:**

- Requiere testing exhaustivo de aislamiento
- Queries SIEMPRE deben incluir tenant_id
- Riesgo de "noisy neighbor"

### Mitigaciones

- **Rate Limiting por Tenant:** Evitar que un tenant afecte a otros
- **Feature Flags por Tenant:** Configuraciones independientes
- **Auditoría:** Logs de acceso por tenant
- **Testing:** Pruebas específicas de aislamiento
