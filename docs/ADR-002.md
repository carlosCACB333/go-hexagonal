# Architecture Decision Records (ADRs)

## ADR-002: CQRS (Command Query Responsibility Segregation)

### Contexto

Los sistemas modernos requieren diferentes optimizaciones para escritura vs lectura. Las operaciones de escritura necesitan validaciones complejas y consistencia, mientras que las lecturas requieren velocidad y escalabilidad.

### Decisión

Implementar **CQRS** separando completamente:

**Write Side (Comandos):**

- Tabla: `users` (normalizada)
- Comandos: `CreateUserCommand`
- Validaciones de dominio
- Generación de eventos
- Publicación a RabbitMQ

**Read Side (Consultas):**

- Tabla: `users_read` (denormalizada)
- Queries: `GetUserQuery`
- Sin lógica de negocio
- Optimizada para lectura

**Sincronización:**

```sh
    Command → Write Model → Event → RabbitMQ → Consumer → Read Model
```

### Ejemplo de Flujo

```go
// WRITE: Comando
type CreateUserCommand struct {
    Name     string
    Email    string
    Password string
}

// El caso de uso guarda en write model y publica evento
cmd_use_case.Execute(cmd) → 
    userWriteRepo.Save(user) → 
    eventBus.Publish(UserCreatedEvent)

// READ: Consumer actualiza read model
consumer.HandleUserCreatedEvent(event) → 
    userReadRepo.Upsert(userDTO)

// Query lee del read model
query_use_case.Execute(query) → 
    userReadRepo.FindByID(id)
```

### Consecuencias

**Positivas:**

- Escalabilidad independiente de lectura/escritura
- Optimización específica por operación
- Facilita caching y replicas de lectura
- Eventual consistency acceptable para muchos casos

**Negativas:**

- Complejidad adicional
- Eventual consistency (no inmediata)
- Duplicación de datos
- Más código para mantener
